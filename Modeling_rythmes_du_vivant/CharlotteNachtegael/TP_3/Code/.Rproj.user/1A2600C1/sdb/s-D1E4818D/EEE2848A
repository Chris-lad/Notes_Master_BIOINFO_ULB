{
    "contents" : "sdValue = c()\nomegaRun = c()\ntoggleRepeat <- function(){ \n  \n  for (omega in seq(5,51)){\n    for (run in 1:30){\n      alpha1 = 2 * omega\n      alpha2 = 2 * omega\n      k1 = 1 * omega\n      k2 = 1 * omega\n      n=4\n      delta1 = 1\n      delta2 = 1\n      \n      ###  Initial condition (concentration)\n      \n      x0=1\n      y0=1\n      \n      ###  Time parameters\n      \n      trans=50\n      tend=100\n      tech=0.05\n      \n      ###  Initialization\n      \n      x=x0*omega\n      y=y0*omega\n      \n      t=0\n      \n      tout=c()\n      xout=c()\n      yout=c()\n      \n      told=0\n      \n      w=rep(0,4)\n      c=rep(0,4)\n      \n      \n      ###  Gillepie loop\n      repeat{\n        swi = 0\n        while(t<trans+tend){\n          \n          w[1] = alpha1 * ((k1)^n/((k1)^n + y^n))\n          w[2] = delta1 * x\n          w[3] = alpha2 * ((k2)^n/((k2)^n + x^n))\n          w[4] = delta2 * y\n          \n          c[1]=w[1]\n          for (j in 2:4)\n            c[j]=c[j-1]+w[j]\n          end\n          \n          ct=c[4]\n          \n          z=runif(2,min=0,max=1)\n          \n          tau=(-log(z[1]))/ct\n          t=t+tau\n          \n          uct=z[2]*ct\n          \n          if (uct < c[1]){\n            x= x+1\n          }\n          else if (uct <= c[2]){\n            x=x-1\n          }\n          else if (uct <= c[3]){\n            y=y+1\n          }\n          else if (uct <= c[4]){\n            y=y-1\n          }\n          \n          if (x == y){\n            swi = 1\n          }\n          \n          if ((t>trans) && (t>told+tech)){\n            tout=c(tout,t-trans)\n            xout=c(xout,x)\n            yout=c(yout,y)\n            told=t\n          }\n          \n          \n        }# end of the while loop\n        if (swi == 0){\n          break\n        }\n      }\n      omegaRun[run] = sd(xout)\n    }\n    #print(omega)\n    #print(mean(omegaRun))\n    sdValue[omega-5] = mean(omegaRun)\n    #write.table(array(c(tout,xout,yout),c(length(tout),3)), col.names=F, row.names=F,\"test.txt\", sep=\"\\t\")\n  }\n  #print(sdValue)\n  #print(5:10)\n  plot(5:50,sdValue)\n  \n}\n\n\ntoggle <- function(omega){ \n  alpha1 = 2 * omega\n  alpha2 = 2 * omega\n  k1 = 1 * omega\n  k2 = 1 * omega\n  n=4\n  delta1 = 1\n  delta2 = 1\n  \n  ###  Initial condition (concentration)\n  \n  x0=1\n  y0=1\n  \n  ###  Time parameters\n  \n  trans=50\n  tend=100\n  tech=0.05\n  \n  ###  Initialization\n  \n  x=x0*omega\n  y=y0*omega\n  \n  t=0\n  \n  tout=c()\n  xout=c()\n  yout=c()\n  \n  told=0\n  \n  w=rep(0,4)\n  c=rep(0,4)\n  \n  \n  ###  Gillepie loop\n    while(t<trans+tend){\n      \n      w[1] = alpha1 * ((k1)^n/((k1)^n + y^n))\n      w[2] = delta1 * x\n      w[3] = alpha2 * ((k2)^n/((k2)^n + x^n))\n      w[4] = delta2 * y\n      \n      c[1]=w[1]\n      for (j in 2:4)\n        c[j]=c[j-1]+w[j]\n      end\n      \n      ct=c[4]\n      \n      z=runif(2,min=0,max=1)\n      \n      tau=(-log(z[1]))/ct\n      t=t+tau\n      \n      uct=z[2]*ct\n      \n      if (uct < c[1]){\n        x= x+1\n      }\n      else if (uct <= c[2]){\n        x=x-1\n      }\n      else if (uct <= c[3]){\n        y=y+1\n      }\n      else if (uct <= c[4]){\n        y=y-1\n      }\n      \n      if ((t>trans) && (t>told+tech)){\n        tout=c(tout,t-trans)\n        xout=c(xout,x)\n        yout=c(yout,y)\n        told=t\n      }\n      \n      \n    }# end of the while loop\n  write.table(array(c(tout,xout,yout),c(length(tout),3)), col.names=F, row.names=F,\"test.txt\", sep=\"\\t\")\n  plot(tout,xout,xlab=\"Time\",ylab=\"x (blue), y (red)\",xlim=c(0,tend),type=\"l\",col=\"blue\")\n  lines(tout,yout,type=\"l\",col=\"red\")\n  \n} #End of function\n\n### Figure\n\n\n#print(yout)\n\n#Espace des phases (pas demande)\n#plot(xout,yout,xlab=\"x\",ylab=\"y\",type=\"l\",col=\"black\")\n\n#print(sd(xout))\n#for the distribution\n#density = density(xout)\n#plot(density)\n\n\n#ecart-type`\n#plot(xout , sd(xout))\n\n# pour quantifier le bruit\n# 1) on peut calculer la distribution statistique, l'écart type pour différentes valeurs de omega (omega vs ecartType/Xm) Xm est la courbe bleue.\n# 2) effet d'un switch IPTG. Choisir une valeur d'omega pas trop petite pour ne pas avoir de transition\n#    spontanée pour que c'est l'IPTG qui induit un switch (omega = 50)\n#    un des effets du bruits: toutes les cellules ne vont pas switcher en même temps\n#    on peut regarder à quelle moment les cellules switch (on peut prendre comme valeur seuil omega)\n#    faire un histogramme du moment ou chaque cellule switch (moment ou la variable x atteint la valeur omega)\n#    une autre manière: regarder à différent temps\n\n\n\n\n\n",
    "created" : 1463033845041.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2260308079",
    "id" : "EEE2848A",
    "lastKnownWriteTime" : 1463033841,
    "path" : "C:/Users/charl/AppData/Local/Temp/toggleSwitch.r",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "type" : "r_source"
}